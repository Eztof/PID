<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>S239 – Trend Viewer & PID-Tuning</title>
  <!-- Tailwind via CDN for quick, clean UI -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js for graphs -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Time adapter for Chart.js time scale -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <!-- Zoom/Pan plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
  <!-- Simple icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root { --bg: #0b1220; --card: #0e1729; --muted: #9fb3c8; --acc: #5eead4; }
    html, body { height: 100%; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; background: linear-gradient(180deg, #0b1220 0%, #0c1426 100%); color: #e6edf5; }
    .card { background: linear-gradient(180deg, #0e1729 0%, #0f1a30 100%); border: 1px solid rgba(255,255,255,.06); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.3); }
    .k { color: var(--acc); }
    .chip { padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.03); font-size: 12px; }
    .btn { background: linear-gradient(180deg, #1b2540 0%, #101a31 100%); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 10px 14px; }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(0,0,0,.25); }
    .input { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 10px 12px; }
    .label { font-size: 12px; color: var(--muted); }
    .grid-areas { display: grid; grid-template-columns: 340px 1fr; grid-template-rows: auto 1fr; gap: 16px; height: calc(100vh - 32px); }
    @media (max-width: 1100px){ .grid-areas { grid-template-columns: 1fr; grid-template-rows: auto auto auto; height: auto; } }
  </style>
</head>
<body>
  <div class="p-4">
    <header class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-3">
      <div>
        <h1 class="text-2xl font-semibold">S239 – Trend Viewer & PID‑Tuning</h1>
        <p class="text-sm text-slate-300">Trendkurven anzeigen, suchen & filtern • PID‑Analyse • Heuristische Vorschläge für XPY1, tN, Vorhalt</p>
      </div>
      <div class="flex items-center gap-2">
        <span class="chip">Einzel‑HTML • offline nutzbar</span>
        <button id="btnExportPNG" class="btn text-sm">PNG exportieren</button>
      </div>
    </header>

    <div class="grid-areas">
      <!-- LEFT: Controls -->
      <aside class="card p-4 flex flex-col gap-4">
        <section class="flex flex-col gap-2">
          <h2 class="text-lg font-semibold">Daten</h2>
          <label class="label">Trenddatei (*.xml nach DDC Trend 1.1)</label>
          <input id="fileInput" type="file" accept=".xml" class="input" />
          <div class="text-xs text-slate-400" id="fileMeta">Noch keine Datei geladen.</div>
        </section>

        <section class="flex flex-col gap-2">
          <div class="flex items-center justify-between">
            <h2 class="text-lg font-semibold">Kurvenauswahl</h2>
            <input id="searchBox" class="input text-sm" placeholder="Suchen… (Adresse/Name)" />
          </div>
          <div id="seriesList" class="max-h-64 overflow-auto pr-1 text-sm"></div>
          <div class="flex gap-2">
            <button id="btnSelectAll" class="btn text-sm">Alle</button>
            <button id="btnSelectNone" class="btn text-sm">Keine</button>
          </div>
        </section>

        <section class="flex flex-col gap-2">
          <h2 class="text-lg font-semibold">Anzeige</h2>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="label">Zeitfenster</label>
              <select id="timeWindow" class="input w-full text-sm">
                <option value="all">Gesamter Zeitraum</option>
                <option value="24h">Letzte 24 h</option>
                <option value="48h">Letzte 48 h</option>
                <option value="7d">Letzte 7 Tage</option>
              </select>
            </div>
            <div>
              <label class="label">Glättung</label>
              <input id="smoothing" type="number" class="input w-full text-sm" min="1" max="99" value="1" />
              <div class="text-xs text-slate-400">Fenster für gleitenden Mittelwert</div>
            </div>
          </div>
        </section>

        <section class="flex flex-col gap-2">
          <h2 class="text-lg font-semibold">PID‑Parameter (S239)</h2>
          <div class="grid grid-cols-2 gap-2">
            <label class="label col-span-2">P‑Band XPY1 [K] (5120)</label>
            <input id="xp" type="number" step="0.1" min="0.5" class="input" value="50" />
            <div class="text-xs text-slate-400">Kleiner = stärkere P‑Verstärkung</div>

            <label class="label col-span-2">Nachstellzeit tN [min] (5106)</label>
            <input id="tn" type="number" step="1" min="1" class="input" value="3" />
            <div class="text-xs text-slate-400">Größer = schwächerer I‑Anteil</div>

            <label class="label col-span-2">Vorhalt (D) [s] (5125)</label>
            <input id="td" type="number" step="1" min="0" class="input" value="0" />
            <div class="text-xs text-slate-400">0 = ohne D‑Anteil</div>

            <label class="label col-span-2">Totzone xwh [K] (5128)</label>
            <input id="xwh" type="number" step="0.1" min="0" class="input" value="0" />
          </div>

          <h3 class="text-base font-semibold mt-2">Heizkurve</h3>
          <div class="grid grid-cols-2 gap-2">
            <label class="label col-span-2">EF – Steilheit (5155)</label>
            <input id="ef" type="number" step="0.1" min="0" max="10" class="input" value="1.5" />

            <label class="label col-span-2">KH – Parallelversch. (5156) [K]</label>
            <input id="kh" type="number" step="1" min="-100" max="100" class="input" value="0" />
          </div>

          <div class="grid grid-cols-2 gap-2">
            <label class="label col-span-2">Regeln nach TA (5152)</label>
            <select id="regTA" class="input text-sm">
              <option value="0">Nein – TAvz (verzögert)</option>
              <option value="1">Ja – aktuelle TA</option>
            </select>
            <label class="label col-span-2">Zeitkonstante TAvz (5168) [h]</label>
            <input id="tavz" type="number" step="1" min="1" max="99" class="input" value="24" />
          </div>

          <button id="btnAnalyse" class="btn w-full">PID‑Analyse & Vorschläge</button>
        </section>
      </aside>

      <!-- RIGHT: Charts & Analysis -->
      <main class="flex flex-col gap-4">
        <section class="card p-4">
          <div class="flex items-center justify-between mb-3">
            <h2 class="text-lg font-semibold">Trendkurven</h2>
            <div class="flex items-center gap-2 text-sm">
              <span class="chip"><span id="pointCount">0</span> Punkte</span>
              <span class="chip">Zoom: Scroll • Pan: Shift+Drag</span>
            </div>
          </div>
          <canvas id="chart" height="320"></canvas>
        </section>

        <section class="card p-4">
          <div class="flex items-center justify-between mb-3">
            <h2 class="text-lg font-semibold">Analyse & Empfehlung</h2>
            <button id="btnSimulate" class="btn text-sm">Kurzprognose (30–120 min)</button>
          </div>
          <div id="analysis" class="text-sm space-y-3">
            <div class="text-slate-300">Lade Trends oder wähle Kurven aus. Für PID‑Analyse ideal: Istwert (z. B. Vorlauf/Regelgröße), TVsoll und Y‑Ausgang.</div>
          </div>
        </section>
      </main>
    </div>
  </div>

  <script>
    // ====== State ======
    const state = {
      meta: null,
      series: new Map(), // key -> { name, address, points: [{t, y}], unit }
      filteredKeys: [],
      selectedKeys: new Set(),
      chart: null,
    };

    // ====== Utils ======
    const fmt = new Intl.DateTimeFormat('de-DE', { dateStyle: 'medium', timeStyle: 'short' });

    function movingAverage(arr, w){
      if(w <= 1) return arr.slice();
      const out = new Array(arr.length);
      let sum = 0;
      for(let i=0;i<arr.length;i++){
        sum += arr[i].y;
        if(i >= w) sum -= arr[i-w].y;
        out[i] = { t: arr[i].t, y: (i < w-1) ? arr[i].y : sum/Math.min(i+1, w) };
      }
      return out;
    }

    function linearRegression(points){
      // points: [{t: ms, y}]
      if(points.length < 2) return {m:0, b:points[0]?.y ?? 0};
      const xs = points.map(p => p.t/1000); // scale to seconds
      const ys = points.map(p => p.y);
      const n = xs.length;
      const sx = xs.reduce((a,b)=>a+b,0);
      const sy = ys.reduce((a,b)=>a+b,0);
      const sxx = xs.reduce((a,b)=>a+b*b,0);
      const sxy = xs.reduce((a,_,i)=>a+xs[i]*ys[i],0);
      const denom = (n*sxx - sx*sx) || 1e-9;
      const m = (n*sxy - sx*sy)/denom;
      const b = (sy - m*sx)/n;
      return {m,b};
    }

    function detectOscillation(points){
      // crude: count peaks via sign changes of derivative
      if(points.length < 5) return {periodMin:null, oscillates:false};
      const dy = [];
      for(let i=1;i<points.length;i++){
        const dt = (points[i].t - points[i-1].t)/60000; // min
        if(dt<=0) continue;
        dy.push((points[i].y - points[i-1].y)/dt);
      }
      const sign = v => v>0?1:(v<0?-1:0);
      let last = sign(dy[0]||0);
      let crossings = [];
      let lastIdx = 0;
      for(let i=1;i<dy.length;i++){
        const s = sign(dy[i]);
        if(s!==0 && last!==0 && s!==last){ crossings.push(i); lastIdx = i; }
        last = s;
      }
      if(crossings.length < 3) return {periodMin:null, oscillates:false};
      const periods = [];
      for(let i=1;i<crossings.length;i++){
        const t1 = points[crossings[i-1]].t;
        const t2 = points[crossings[i]].t;
        periods.push((t2-t1)/60000);
      }
      const avg = periods.reduce((a,b)=>a+b,0)/periods.length;
      return {periodMin: avg, oscillates: true};
    }

    function computeTVsoll(ta, ef, kh){
      // TVsollTag = 20 + KH - EF * (TA(vz) -24)     für TA<15°C
      // TVsollTag = 20 + KH - EF * (1,8*TA(vz)-36)  für TA>=15°C
      const tv = (ta < 15) ? (20 + kh - ef * (ta - 24)) : (20 + kh - ef * (1.8*ta - 36));
      return tv;
    }

    function lowpass(series, tauHours){
      // simple first-order IIR over timestamps
      if(series.length === 0) return [];
      const out = [];
      let y = series[0].y; out.push({t: series[0].t, y});
      for(let i=1;i<series.length;i++){
        const dt = (series[i].t - series[i-1].t)/3600000; // hours
        const a = dt / Math.max(tauHours, 1e-3);
        const alpha = a/(1+a);
        y = y + alpha * (series[i].y - y);
        out.push({t: series[i].t, y});
      }
      return out;
    }

    function chooseRecent(points, window){
      if(window==='all' || points.length===0) return points;
      const lastT = points[points.length-1].t;
      const span = window==='24h'?24*3600000:window==='48h'?48*3600000:7*24*3600000;
      const from = lastT - span;
      return points.filter(p=>p.t>=from);
    }

    function summarize(arr){
      if(arr.length===0) return null;
      const ys = arr.map(p=>p.y);
      const min = Math.min(...ys), max = Math.max(...ys);
      const mean = ys.reduce((a,b)=>a+b,0)/ys.length;
      return {min, max, mean};
    }

    function heuristicTuning(metrics){
      // metrics: { offset, overshoot, oscillates, periodMin }
      const rec = [];
      // P‑Band (XPY1): kleiner = stärker
      if(metrics.oscillates || metrics.overshoot>0.1){
        rec.push("XPY1 vergrößern (geringere P‑Verstärkung) für mehr Dämpfung.");
      } else if(Math.abs(metrics.offset) > 0.5){
        rec.push("XPY1 verkleinern (stärkere P‑Verstärkung), um den statischen Fehler zu reduzieren.");
      }
      // I‑Anteil
      if(Math.abs(metrics.offset) > 0.5){
        rec.push("tN verkleinern (stärkerer I‑Anteil), falls anhaltender Offset.");
      }
      if(metrics.oscillates){
        rec.push("tN vergrößern (schwächerer I‑Anteil), falls Integralschwingungen sichtbar.");
      }
      // D‑Anteil
      if(metrics.overshoot>0.1 && !metrics.oscillates){
        rec.push("Vorhalt (D) leicht erhöhen, um Überschwinger zu dämpfen.");
      }
      if(rec.length===0) rec.push("Parameter erscheinen plausibel. Feintuning vorsichtig in kleinen Schritten.");
      return rec;
    }

    // ====== Parsing ======
    async function parseTrendXML(file){
      const text = await file.text();
      const xml = new DOMParser().parseFromString(text, 'application/xml');
      const hdr = xml.querySelector('Header');
      state.meta = {
        central: hdr?.querySelector('CentralName')?.textContent || '–',
        ts: hdr?.querySelector('TimeStamp')?.textContent || null,
      };
      state.series.clear();
      const objs = Array.from(xml.querySelectorAll('TrendObject'));
      for(const obj of objs){
        const address = obj.getAttribute('Address') || '–';
        const name = obj.querySelector('PlainAddress')?.textContent || address;
        const entries = Array.from(obj.querySelectorAll('Entry'));
        const pts = entries.map(e=>({
          t: new Date(e.getAttribute('TimeStamp')).getTime(),
          y: Number(e.getAttribute('Value')),
        })).sort((a,b)=>a.t-b.t);
        const key = name.trim();
        state.series.set(key, { name: key, address, points: pts, unit: '' });
      }
      state.filteredKeys = [...state.series.keys()].sort();
      state.selectedKeys = new Set(state.filteredKeys.slice(0, Math.min(3, state.filteredKeys.length)));
      renderSeriesList();
      renderChart();
      document.getElementById('fileMeta').textContent = `${state.meta.central} • ${state.filteredKeys.length} Kurven`;
    }

    // ====== UI Render ======
    function renderSeriesList(){
      const box = document.getElementById('seriesList');
      const q = (document.getElementById('searchBox').value||'').toLowerCase();
      const keys = [...state.series.keys()].filter(k=>k.toLowerCase().includes(q));
      state.filteredKeys = keys;
      box.innerHTML = '';
      keys.forEach(k=>{
        const row = document.createElement('label');
        row.className = 'flex items-center gap-2 py-1 border-b border-white/5';
        const cb = document.createElement('input');
        cb.type='checkbox'; cb.className='accent-cyan-300'; cb.checked = state.selectedKeys.has(k);
        cb.addEventListener('change', ()=>{ if(cb.checked) state.selectedKeys.add(k); else state.selectedKeys.delete(k); renderChart(); });
        const span = document.createElement('span'); span.textContent = k; span.title = k;
        row.appendChild(cb); row.appendChild(span);
        box.appendChild(row);
      });
    }

    function color(idx){
      // Generate pleasing distinct hues
      const h = (idx*57) % 360; const s = 70; const l = 55;
      return `hsl(${h} ${s}% ${l}%)`;
    }

    function renderChart(){
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');
      const smoothing = Math.max(1, Number(document.getElementById('smoothing').value||1));
      const windowSel = document.getElementById('timeWindow').value;

      const datasets = [];
      let totalPoints = 0;
      [...state.selectedKeys].forEach((k, i)=>{
        const raw = state.series.get(k)?.points || [];
        const win = chooseRecent(raw, windowSel);
        const pts = movingAverage(win, smoothing);
        totalPoints += pts.length;
        datasets.push({
          label: k,
          data: pts.map(p=>({x: p.t, y: p.y})),
          borderWidth: 2,
          tension: 0.2,
          borderColor: color(i),
          pointRadius: 0,
        });
      });
      document.getElementById('pointCount').textContent = totalPoints;

      if(state.chart){ state.chart.destroy(); }
      state.chart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'x', intersect: false },
          parsing: false,
          scales: {
            x: {
              type: 'time',
              time: { unit: 'hour' },
              grid: { color: 'rgba(255,255,255,.06)' },
              ticks: { color: '#c9d4e5' }
            },
            y: {
              grid: { color: 'rgba(255,255,255,.06)' },
              ticks: { color: '#c9d4e5' }
            }
          },
          plugins: {
            legend: { labels: { color: '#e6edf5' } },
            tooltip: {
              callbacks: {
                label: (ctx)=> `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)}`
              }
            },
            zoom: {
              pan: { enabled: true, mode: 'x', modifierKey: 'shift' },
              zoom: {
                wheel: { enabled: true, modifierKey: 'ctrl' }, // Zoom nur mit STRG + Scroll
                pinch: { enabled: false }, // Pinch-Zoom aus
                drag: { enabled: false }, // Drag-Zoom aus
                mode: 'x' // ausschließlich X-Achse
              }
            }, mode: 'x' },
              pan: { enabled: true, modifierKey: 'shift', mode: 'x' }
            }
          }
        }
      });
    }

    // ====== Analysis ======
    function getSeriesByNameContains(fragment){
      fragment = fragment.toLowerCase();
      for(const [k,v] of state.series){ if(k.toLowerCase().includes(fragment)) return v; }
      return null;
    }

    function analysePID(){
      const xp = Number(document.getElementById('xp').value);
      const tn = Number(document.getElementById('tn').value);
      const td = Number(document.getElementById('td').value);
      const xwh = Number(document.getElementById('xwh').value);
      const ef = Number(document.getElementById('ef').value);
      const kh = Number(document.getElementById('kh').value);
      const regTA = Number(document.getElementById('regTA').value);
      const tavz = Number(document.getElementById('tavz').value);

      // Try to infer typical variable names if present
      const pv = getSeriesByNameContains('Regelgröße') || getSeriesByNameContains('Vorlauf') || getSeriesByNameContains('TV');
      const ta = getSeriesByNameContains('Außentemperatur') || getSeriesByNameContains('Aussentemperatur');
      const y = getSeriesByNameContains('Heizventil') || getSeriesByNameContains('YH1') || getSeriesByNameContains('Y');
      const tvsollSeries = getSeriesByNameContains('TVSoll aktuell') || getSeriesByNameContains('TVsoll');

      let tvsoll = null;
      if(tvsollSeries){
        tvsoll = tvsollSeries.points;
      } else if(ta){
        const taPts = regTA ? ta.points : lowpass(ta.points, tavz);
        tvsoll = taPts.map(p=>({t:p.t, y: computeTVsoll(p.y, ef, kh)}));
      }

      const pvPts = pv?.points || [];
      const yPts  = y?.points  || [];

      const windowSel = document.getElementById('timeWindow').value;
      const pvWin = chooseRecent(pvPts, windowSel);
      const yWin  = chooseRecent(yPts, windowSel);
      const tvWin = chooseRecent(tvsoll||[], windowSel);

      // Align by timestamps (nearest neighbor)
      function resample(ref, other){
        if(!ref || !other || ref.length===0 || other.length===0) return [];
        let j=0; const out=[]; const n=other.length;
        for(const p of ref){
          while(j<n-1 && Math.abs(other[j+1].t - p.t) < Math.abs(other[j].t - p.t)) j++;
          out.push({t:p.t, y: other[j].y});
        }
        return out;
      }
      const yOnPv = resample(pvWin, yWin);
      const tvOnPv = resample(pvWin, tvWin);

      // Metrics
      let offset=0, overshoot=0, osc=false, per=null;
      if(tvOnPv.length && pvWin.length){
        const lastPv = pvWin[pvWin.length-1].y;
        const lastSp = tvOnPv[tvOnPv.length-1].y;
        offset = lastPv - lastSp; // K
        const s = summarize(pvWin);
        if(s){ overshoot = Math.max(0, (s.max - lastSp) / Math.max(1, Math.abs(lastSp))); }
        const oscInfo = detectOscillation(pvWin);
        osc = oscInfo.oscillates; per = oscInfo.periodMin;
      }
      const kP = 100/Math.max(0.0001, xp); // heuristic conversion (Y% per K)

      const metrics = { offset, overshoot, oscillates: osc, periodMin: per, kP, tn, td, xwh };
      const recommendations = heuristicTuning(metrics);

      const lines = [
        `<div class='text-slate-300'>Erkannte Kurven: ${pv?"Ist/PV":"–"}, ${tvsoll?"TVsoll":"–"}, ${y?"Y-Ausgang":"–"}</div>`,
        `<div><span class='k'>Offset</span> Ist – Soll: <b>${offset.toFixed(2)} K</b></div>`,
        `<div><span class='k'>Überschwingen</span>: <b>${(overshoot*100).toFixed(1)}%</b>${per?`, vermutete Periodendauer ~ <b>${per.toFixed(0)} min</b>`:''}</div>`,
        `<div class='mt-2'><span class='k'>Gegenwärtige Parametrierung</span>: XPY1=${xp} K, tN=${tn} min, D=${td} s, xwh=${xwh} K → angenäherte P‑Verstärkung kP≈${kP.toFixed(2)} %/K</div>`,
        `<div class='mt-2'><span class='k'>Vorschläge (heuristisch)</span><ul class='list-disc ml-6 mt-1'>${recommendations.map(r=>`<li>${r}</li>`).join('')}</ul></div>`
      ];

      document.getElementById('analysis').innerHTML = lines.join('');
    }

    function shortForecast(){
      // Take the most selected series as reference and project 2h ahead
      const key = [...state.selectedKeys][0];
      if(!key){ alert('Bitte eine Kurve auswählen.'); return; }
      const pts = state.series.get(key)?.points || [];
      const sel = chooseRecent(pts, '24h');
      if(sel.length < 10){ alert('Zu wenige Punkte für Prognose.'); return; }
      const last = sel[sel.length-1].t;
      const recent = sel.slice(-Math.min(120, Math.floor(sel.length*0.6)));
      const {m,b} = linearRegression(recent);
      const f = [];
      for(let i=5;i<=120;i+=5){
        const t = last + i*60000; // minutes ahead
        const y = m*(t/1000) + b;
        f.push({x: t, y});
      }
      // add as dashed dataset
      state.chart.data.datasets = state.chart.data.datasets.filter(d=>!d._isForecast);
      state.chart.data.datasets.push({
        label: key + ' – Prognose',
        data: f,
        borderWidth: 2,
        borderDash: [6,6],
        tension: 0,
        pointRadius: 0,
        borderColor: 'rgba(94,234,212,.9)',
        _isForecast: true,
      });
      state.chart.update();
    }

    // ====== Events ======
    document.getElementById('fileInput').addEventListener('change', (e)=>{
      const file = e.target.files?.[0];
      if(file) parseTrendXML(file);
    });
    document.getElementById('searchBox').addEventListener('input', renderSeriesList);
    document.getElementById('smoothing').addEventListener('change', renderChart);
    document.getElementById('timeWindow').addEventListener('change', renderChart);
    document.getElementById('btnSelectAll').addEventListener('click', ()=>{ state.filteredKeys.forEach(k=>state.selectedKeys.add(k)); renderSeriesList(); renderChart(); });
    document.getElementById('btnSelectNone').addEventListener('click', ()=>{ state.selectedKeys.clear(); renderSeriesList(); renderChart(); });
    document.getElementById('btnAnalyse').addEventListener('click', analysePID);
    document.getElementById('btnSimulate').addEventListener('click', shortForecast);
    document.getElementById('btnExportPNG').addEventListener('click', ()=>{
      const a = document.createElement('a');
      a.href = document.getElementById('chart').toDataURL('image/png');
      a.download = 'trend-chart.png'; a.click();
    });

    // ====== Demo: enable drop of XML onto page ======
    document.addEventListener('dragover', (e)=>{ e.preventDefault(); });
    document.addEventListener('drop', (e)=>{
      e.preventDefault();
      const file = [...(e.dataTransfer?.files||[])].find(f=>f.name.toLowerCase().endsWith('.xml'));
      if(file) parseTrendXML(file);
    });
  </script>
</body>
</html>
